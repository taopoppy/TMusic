# TMusic
taopoppy's music 

# 项目重点
本项目重点有下面几个
+ 小程序页面编写
  + 原生组件的使用
  + flex布局的运用
+ 公共机制
  + 数据请求封装(request)
  + 缓存机制(storage和getApp)
  + 公共资源(image和icon)
+ 小程序基础功能
  + 小程序授权
  + 小程序分享
  + 小程序支付


## assets资源文件
我们首先来从每个文件夹说起，首先assets文件说起，这个文件是放资源的文件：
+ 使用资源文件的图片尽量使用绝对路径，这样比较方便检查且不容易出错
+ 关于icon的使用，需要在iconfont的网站上找好图标，或者边写边找，每次刷新代码，重新拷贝即可。找好图标，我们粘贴到代码当中即可使用，使用注意两个方面
  + page页面当中直接使用icon是没有问题的，但是components当中使用icon是要在组件的wxss当中引入iconfont.wxss（可见app.wxss的作用范围只在page当中）
  + icon的重点是字体类型（font-family），字体大小（font-size）和颜色（color）,要想图标正常显示，不能少了这三个元素


## components自定义组件
接着再来看组件，小程序可以自定义组件，创建文件夹后右击选择新建Component即可，好的习惯是自定义组件下面的文件全部叫做index
+ banner轮播图组件（无特殊解释的点,主要是去查询微信轮播图组件swiper）

+ comment评论组件（无特殊解释的点,flex布局）

+ lyric歌词组件
  + observers监听器：因为从服务器取出来的歌词数据不是正规的数组，掺杂着歌词对应时间是个复杂的字符串，利用监听器，监听到有歌词的时候，就将其转换成利于我们展示的数组格式
    + 监听器一般用于两个地方：由于数据的改变需要额外做一些事情，或者传递进入的数据格式需要做转换
  
  + 事件触发：自定义组件里面很多的事件处理是要交给使用它的父组件的，所以我们需要将自定义组件自己触发的事件传播出去，传播给它的父组件，父组件监听即可，语法如下：this.triggerEvent('事件名称',事件参数)
  
  + 组件生命周期：自定义组件也有生命周期，而已有两种，lifetimes和pageLifetimes，前者是组件内部的生命周期，后者是组件在页面展示的生命周期，与页面操作组件有关

+ musiclist歌单组件
  + dataset属性：因为小程序的事件不能像react或者vue直接在html当中传递参数，所以可以在节点有事件的时候，给节点传递data-xx属性，作为处理事件函数的参数，可以在函数中通过event.currentTarget.dataset.xx拿到
  
  + 路由跳转： 小程序路由跳转有下面几个可以调用的API
    + wx.reLaunch:关闭所有页面，打开到应用内的某个页面
    + wx.redirectTo:关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面
    + wx.navigateTo:保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层

+ playlist歌单封面组件
  + 使用svg做背景图：首先要将svg图转换成base64字符串，然后放在这样的格式当中：background: url(data:image/svg+xml;base64,xxxxxxxxx) 其他background属性;

  + 原生的组件：使用到了三个原生的组件: movable-area, movable-view和progress

+ searchinput输入组件
  + 外部样式类: 组件希望接受外部传入的样式类，一般用于两种情况，第一种，组件的所有样式和显示并非能够一次性写全，有一部分需要根据不同的使用者决定，所以这部分的样式应该由父组件传入，第二种情况是有些样式在组件中无效，只能通过父组件来传入的方式，外部样式类需要通过externalClasses这个数组来接收属性。


## store数据缓存
接着我们看一下store，因为在http请求的时候需要和缓存同时结合使用，所以先说明一下：
+ index.js: 这个文件是定义设置缓存，取缓存，清除缓存的基础文件，getItem取缓存，调用这个函数只需要关心结果，不需要关心缓存是否过期，在函数当中有自己的判断，如果过期，会先删除，然后返回null,所以能取出来就能用，取不出来就是没有。setItem设置缓存是一个基础的函数，传递key，value，选择性的传递过期时间，时间需要以毫秒为单位自己计算一下。

+ getStorageData.js: 文件是用来定义一部分缓存的相关操作，比如缓存的读取，更新，删除一部分，根据id取到缓存的下一个数据等等，那么这里要说明的是，这里定义的缓存是比较特殊的，是由用户操作所产生的缓存，而且这些缓存的特点是除了设置和读取，还有一些特殊的操作，比如修改顺序，拿到缓存中某一条数据等等。而在http当中的缓存只是为了减少http请求，提高页面渲染的速度而产生的，那些可以直接写在http当中，也可以写在store文件中，只不过也区分开来，这样能让结构更加清晰。

+ getStorage: 这个文件夹里的文件就是相关每条缓存的具体操作，没有其他多解释的


## http网络请求
下面我们来看http数据请求这个公共机制：
+ request.js: 这部分就涉及到了网络请求的封装，因为关于小程序，它有原生的网络请求的api，所以我们就直接用，但是用于成功和失败是写在success和fail函数当中的，有点类似于node当中的回调，所以我们封装成统一的promise结构，然后在程序当中同步的写法使用async和await，异步的写法可以使用.then，非常灵活。其次由于小程序提供了toast和loading两个比较好用的api，我们可以通过选择的方式传入进去，使用者可以根据需要进行显示，需要加载效果，需要请求提示的，统一在option当中进行配置即可

+ api.js: 这部分主要就是集中管理的请求API的地址

+ getData.js: 这个部分就是对请求函数进行对外暴露

+ getDataFunc: 这个文件夹的文件就是具体针对每个http请求进行的封装，因为这些http大部分都是请求的歌曲，歌单数据，播放地址等等，所以属于网络缓存，但是对于这些网络请求，分为下面几种情况：
  + 请求是由于用户操作而产生的：比如微信授权，网易云账号登录，搜索历史，歌曲播放，正在播放歌曲，这些缓存相关的具体操作我们都封装在了store当中
  + 请求是app需要展示数据而产生的：比如轮播图数据，歌单数据，搜索结果数据等等，但是这里的数据又分为两种：
    + 一种是每天都不一样，或者说每次打开小程序都不一样的，比如轮播图数据，首页推荐歌单，这些我们直接就放在app.globalData当中
    + 另外一种是数据本省不会轻易发生变化，比如某个歌单里的歌曲数据，一般是固定的，这类就放在缓存当中，控制一定的数量，这样的话和app.globalData都是可以起到减少请求，减低服务器压力的效果

+ getDataFunc里面的每个文件，我们都简单的说一遍：
  + getBannerData.js: 轮播图数据差不多一天一变，不需要缓存太久，放在app.globalData即可
  + getHotSearch.js: 热搜数据差不多时时在变，所以缓存15分钟即可，放在app.globalData即可
  + getRecommendList.js： 首页推荐歌单，每天一遍，不需要缓存太久，放在app.globalData即可
  + getRecommendVideos.js： 获取推荐视频，需要登录，时时在边，缓存30分钟接口，放在app.globalData即可

  + getPlayListData.js: 首页歌单里对应的歌曲数据，一个歌单对应的歌曲数据一般不会变，但是为了防止用户从首页进入几次产生重复请求，将其缓存，缓存歌单数量不超过10个，队列模式
  + getSongLyric.js: 歌词缓存，重复播放的歌曲不能重复请求歌词，所以将其缓存，数量不超过30个，队列模式
  + getSongUrl.js: 歌曲播放地址缓存，重复播放的歌曲不能重复请求播放地址，所以将其缓存，数量不超过30个，队列模式

  + getOpenId.js: 微信用户的信息，逻辑封装在store当中
  + getSongDetail.js： 获取音乐具体的信息，需要缓存，因为播放的音乐可以在播放列表当中，具体信息可以从缓存中直接拿到，不需要请求，逻辑封装在store当中
  + getWangYiYunUser.js： 网易云用户的信息，逻辑封装在store当中

  + getSearchResult.js: 搜索结果，不需要缓存，我不相信有人能一天搜100遍周杰伦
  + getVideoComment.js：视频评论，不需要缓存，我不相信有人能一天看同一个视频10遍（除非很自恋）

## route路由
其实路由封装我个人觉的没有必要，因为就4个相关的API,而且语义清晰，一行代码的事，为何要封装

## utils工具
工具这个公共机制，封装的随意性比较大，都是函数，根据自己的需要进行创建文件，进行分类即可

## wxs文件
wxml里面的语法是不支持函数的，比如这样`<view wx:if="{{hasNumber(array1)}}"></view>`，这种情况我们就可以引入wxs文件，将函数写在wxs文件当中，然后在wxml当中这样引入：`<wxs module="utils" src="../index.wxs"></wxs>`

## page页面
关于页面的书写，这个应该是小程序的基础能力，就不多说，值得提倡的有下面几点：
+ 因为this.setData是同步的，所以和页面绑定的data需要使用this.setData，没有绑定的直接this.data._xxx = yyy 进行修改，且使用_来标注它是和页面无绑定的data

其他关于小程序的写法和能力，在官网都能查得到，熟悉官网，提高书写效率，尤其是写页面的时候，一定要先写页面框架，最后书写样式，速度非常快。class的名称定义尽量有规则，比如特殊标签的外包裹使用class="xxx-warp"，非特殊的直接使用class="xxx-view"